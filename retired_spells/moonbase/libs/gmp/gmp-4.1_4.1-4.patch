--- gmpxx.h.old	Wed Jul  3 10:45:48 2002
+++ gmpxx.h	Wed Jul  3 10:49:28 2002
@@ -2633,10 +2633,18 @@
   }
 
   // conversion functions
-  const mpz_classref get_num() const { return mpz_classref(mpq_numref(mp)); }
-  mpz_classref get_num() { return mpz_classref(mpq_numref(mp)); }
-  const mpz_classref get_den() const { return mpz_classref(mpq_denref(mp)); }
-  mpz_classref get_den() { return mpz_classref(mpq_denref(mp)); }
+
+  // casting a reference to an mpz_t to mpz_class & is a dirty hack,
+  // but works because the internal representation of mpz_class is
+  // exactly an mpz_t
+  const mpz_class & get_num() const
+  { return reinterpret_cast<const mpz_class &>(*mpq_numref(mp)); }
+  mpz_class & get_num()
+  { return reinterpret_cast<mpz_class &>(*mpq_numref(mp)); }
+  const mpz_class & get_den() const
+  { return reinterpret_cast<const mpz_class &>(*mpq_denref(mp)); }
+  mpz_class & get_den()
+  { return reinterpret_cast<mpz_class &>(*mpq_denref(mp)); }
 
   mpq_srcptr get_mpq_t() const { return mp; }
   mpq_ptr get_mpq_t() { return mp; }
--- mpf/inp_str.c.old	Tue Jan  2 18:53:42 2001
+++ mpf/inp_str.c	Wed Jul  3 10:57:33 2002
@@ -64,6 +64,7 @@
       c = getc (stream);
     }
   ungetc (c, stream);
+  nread--;
 
   if (str_size >= alloc_size)
     {
@@ -74,9 +75,10 @@
   str[str_size] = 0;
 
   retval = mpf_set_str (rop, str, base);
+  (*__gmp_free_func) (str, alloc_size);
+
   if (retval == -1)
     return 0;			/* error */
 
-  (*__gmp_free_func) (str, alloc_size);
   return str_size + nread;
 }
--- mpz/powm_ui.c.old	Thu May 16 09:20:49 2002
+++ mpz/powm_ui.c	Sat Jun  1 10:41:34 2002
@@ -115,6 +115,17 @@
 
   /* Main loop. */
 
+  /* If m is already normalized (high bit of high limb set), and b is the
+     same size, but a bigger value, and e==1, then there's no modular
+     reductions done and we can end up with a result out of range at the
+     end. */
+  if (c == 0)
+    {
+      if (xn == mn && mpn_cmp (xp, mp, mn) >= 0)
+        mpn_sub_n (xp, xp, mp, mn);
+      goto finishup;
+    }
+
   while (c != 0)
     {
       mpn_sqr_n (tp, xp, xn);
@@ -149,6 +160,7 @@
       c--;
     }
 
+ finishup:
   /* We shifted m left m_zero_cnt steps.  Adjust the result by reducing
      it with the original MOD.  */
   if (m_zero_cnt != 0)
--- randraw.c.old	2002/05/14 16:59:44	1.18
+++ randraw.c	2002/06/09 08:12:03	1.19
@@ -112,10 +112,8 @@
   if (seedn == 0)
     {
       /* Seed is 0.  Result is C % M.  Assume table is sensibly stored,
-       with C smaller than M*/
+	 with C smaller than M.  */
       *rp = c;
-
-      ASSERT_ALWAYS (((mp_limb_t) 1 << m2exp) > c);
 
       *seedp = c;
       SIZ (rstate->_mp_seed) = 1;
--- mpn/s390/gmp-mparam.h.old	Wed May 15 21:32:57 2002
+++ mpn/s390/gmp-mparam.h	Wed May 15 21:33:21 2002
@@ -20,7 +20,8 @@
 MA 02111-1307, USA. */
 
 
-/* BITS_PER_MP_LIMB etc generated by configure */
+#define BITS_PER_MP_LIMB 32
+#define BYTES_PER_MP_LIMB 4
 
 
 /* Generated by tuneup.c, 2001-12-03, gcc 2.95 */
